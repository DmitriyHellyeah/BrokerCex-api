# coding: utf-8

"""
    Broker API.

    the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec. There are no TOS at this moment, use at your own risk we take no responsibility  # noqa: E501

    OpenAPI spec version: 0.0.1
    Contact: support@cexbro.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class MarketDataEvent(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'ask': 'object',
        'bid': 'object',
        'candle_type': 'str',
        'close': 'object',
        'high': 'object',
        'low': 'object',
        'open': 'object',
        'symbol': 'str',
        'time': 'datetime',
        'type': 'MarketDataType',
        'volume': 'object'
    }

    attribute_map = {
        'ask': 'ask',
        'bid': 'bid',
        'candle_type': 'candleType',
        'close': 'close',
        'high': 'high',
        'low': 'low',
        'open': 'open',
        'symbol': 'symbol',
        'time': 'time',
        'type': 'type',
        'volume': 'volume'
    }

    def __init__(self, ask=None, bid=None, candle_type=None, close=None, high=None, low=None, open=None, symbol=None, time=None, type=None, volume=None):  # noqa: E501
        """MarketDataEvent - a model defined in Swagger"""  # noqa: E501

        self._ask = None
        self._bid = None
        self._candle_type = None
        self._close = None
        self._high = None
        self._low = None
        self._open = None
        self._symbol = None
        self._time = None
        self._type = None
        self._volume = None
        self.discriminator = None

        if ask is not None:
            self.ask = ask
        if bid is not None:
            self.bid = bid
        if candle_type is not None:
            self.candle_type = candle_type
        if close is not None:
            self.close = close
        if high is not None:
            self.high = high
        if low is not None:
            self.low = low
        if open is not None:
            self.open = open
        if symbol is not None:
            self.symbol = symbol
        if time is not None:
            self.time = time
        if type is not None:
            self.type = type
        if volume is not None:
            self.volume = volume

    @property
    def ask(self):
        """Gets the ask of this MarketDataEvent.  # noqa: E501


        :return: The ask of this MarketDataEvent.  # noqa: E501
        :rtype: object
        """
        return self._ask

    @ask.setter
    def ask(self, ask):
        """Sets the ask of this MarketDataEvent.


        :param ask: The ask of this MarketDataEvent.  # noqa: E501
        :type: object
        """

        self._ask = ask

    @property
    def bid(self):
        """Gets the bid of this MarketDataEvent.  # noqa: E501


        :return: The bid of this MarketDataEvent.  # noqa: E501
        :rtype: object
        """
        return self._bid

    @bid.setter
    def bid(self, bid):
        """Sets the bid of this MarketDataEvent.


        :param bid: The bid of this MarketDataEvent.  # noqa: E501
        :type: object
        """

        self._bid = bid

    @property
    def candle_type(self):
        """Gets the candle_type of this MarketDataEvent.  # noqa: E501


        :return: The candle_type of this MarketDataEvent.  # noqa: E501
        :rtype: str
        """
        return self._candle_type

    @candle_type.setter
    def candle_type(self, candle_type):
        """Sets the candle_type of this MarketDataEvent.


        :param candle_type: The candle_type of this MarketDataEvent.  # noqa: E501
        :type: str
        """

        self._candle_type = candle_type

    @property
    def close(self):
        """Gets the close of this MarketDataEvent.  # noqa: E501


        :return: The close of this MarketDataEvent.  # noqa: E501
        :rtype: object
        """
        return self._close

    @close.setter
    def close(self, close):
        """Sets the close of this MarketDataEvent.


        :param close: The close of this MarketDataEvent.  # noqa: E501
        :type: object
        """

        self._close = close

    @property
    def high(self):
        """Gets the high of this MarketDataEvent.  # noqa: E501


        :return: The high of this MarketDataEvent.  # noqa: E501
        :rtype: object
        """
        return self._high

    @high.setter
    def high(self, high):
        """Sets the high of this MarketDataEvent.


        :param high: The high of this MarketDataEvent.  # noqa: E501
        :type: object
        """

        self._high = high

    @property
    def low(self):
        """Gets the low of this MarketDataEvent.  # noqa: E501


        :return: The low of this MarketDataEvent.  # noqa: E501
        :rtype: object
        """
        return self._low

    @low.setter
    def low(self, low):
        """Sets the low of this MarketDataEvent.


        :param low: The low of this MarketDataEvent.  # noqa: E501
        :type: object
        """

        self._low = low

    @property
    def open(self):
        """Gets the open of this MarketDataEvent.  # noqa: E501


        :return: The open of this MarketDataEvent.  # noqa: E501
        :rtype: object
        """
        return self._open

    @open.setter
    def open(self, open):
        """Sets the open of this MarketDataEvent.


        :param open: The open of this MarketDataEvent.  # noqa: E501
        :type: object
        """

        self._open = open

    @property
    def symbol(self):
        """Gets the symbol of this MarketDataEvent.  # noqa: E501


        :return: The symbol of this MarketDataEvent.  # noqa: E501
        :rtype: str
        """
        return self._symbol

    @symbol.setter
    def symbol(self, symbol):
        """Sets the symbol of this MarketDataEvent.


        :param symbol: The symbol of this MarketDataEvent.  # noqa: E501
        :type: str
        """

        self._symbol = symbol

    @property
    def time(self):
        """Gets the time of this MarketDataEvent.  # noqa: E501


        :return: The time of this MarketDataEvent.  # noqa: E501
        :rtype: datetime
        """
        return self._time

    @time.setter
    def time(self, time):
        """Sets the time of this MarketDataEvent.


        :param time: The time of this MarketDataEvent.  # noqa: E501
        :type: datetime
        """

        self._time = time

    @property
    def type(self):
        """Gets the type of this MarketDataEvent.  # noqa: E501


        :return: The type of this MarketDataEvent.  # noqa: E501
        :rtype: MarketDataType
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this MarketDataEvent.


        :param type: The type of this MarketDataEvent.  # noqa: E501
        :type: MarketDataType
        """

        self._type = type

    @property
    def volume(self):
        """Gets the volume of this MarketDataEvent.  # noqa: E501


        :return: The volume of this MarketDataEvent.  # noqa: E501
        :rtype: object
        """
        return self._volume

    @volume.setter
    def volume(self, volume):
        """Sets the volume of this MarketDataEvent.


        :param volume: The volume of this MarketDataEvent.  # noqa: E501
        :type: object
        """

        self._volume = volume

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(MarketDataEvent, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, MarketDataEvent):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
